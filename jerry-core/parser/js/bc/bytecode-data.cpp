/* Copyright 2015 Samsung Electronics Co., Ltd.
 * Copyright 2015 University of Szeged.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "bytecode-data.h"
#include "pretty-printer.h"

static bytecode_data_header_t *first_bytecode_header_p = NULL;

bytecode_data_header_t *
jsp_bc_get_first_bytecode_data_header ()
{
  return first_bytecode_header_p;
} /* jsp_bc_get_first_bytecode_header */

void
jsp_bc_add_bytecode_data (bytecode_data_header_t *bc_header_p,
                          lit_id_hash_table *lit_id_hash_table_p,
                          vm_instr_t *bytecode_p,
                          vm_instr_counter_t instrs_count)
{
  MEM_CP_SET_POINTER (bc_header_p->lit_id_hash_cp, lit_id_hash_table_p);
  bc_header_p->instrs_p = bytecode_p;
  bc_header_p->instrs_count = instrs_count;
  MEM_CP_SET_POINTER (bc_header_p->next_header_cp, first_bytecode_header_p);

  first_bytecode_header_p = bc_header_p;
} /* jsp_bc_add_bytecode */

/**
 * Deletes bytecode and associated hash table
 */
void
jsp_bc_remove_bytecode_data (const bytecode_data_header_t *bytecode_data_p)
{
  bytecode_data_header_t *prev_header = NULL;
  bytecode_data_header_t *cur_header_p = first_bytecode_header_p;

  while (cur_header_p != NULL)
  {
    if (cur_header_p == bytecode_data_p)
    {
      if (prev_header)
      {
        prev_header->next_header_cp = cur_header_p->next_header_cp;
      }
      else
      {
        first_bytecode_header_p = MEM_CP_GET_POINTER (bytecode_data_header_t, cur_header_p->next_header_cp);
      }
      mem_heap_free_block (cur_header_p);
      break;
    }

    prev_header = cur_header_p;
    cur_header_p = MEM_CP_GET_POINTER (bytecode_data_header_t, cur_header_p->next_header_cp);
  }
} /* jsp_bc_remove_bytecode_data */

vm_instr_t bc_get_instr (const bytecode_data_header_t *bytecode_data_p,
                         vm_instr_counter_t oc)
{
  JERRY_ASSERT (oc < bytecode_data_p->instrs_count);
  return bytecode_data_p->instrs_p[oc];
}

void
bc_print_instrs (const bytecode_data_header_t *bytecode_data_p)
{
#ifdef JERRY_ENABLE_PRETTY_PRINTER
  for (vm_instr_counter_t loc = 0; loc < bytecode_data_p->instrs_count; loc++)
  {
    op_meta opm;

    opm.op = bytecode_data_p->instrs_p[loc];
    for (int i = 0; i < 3; i++)
    {
      opm.lit_id[i] = NOT_A_LITERAL;
    }

    pp_op_meta (bytecode_data_p, loc, opm, false);
  }
#else
  (void) bytecode_data_p;
#endif
}

/**
 * Merge scopes tree into bytecode
 *
 * @return pointer to generated bytecode
 */
const bytecode_data_header_t *
bc_merge_scopes_into_bytecode (scopes_tree scope_p,
                               bool is_show_instrs)
{
  const size_t buckets_count = scopes_tree_count_literals_in_blocks (scope_p);
  const vm_instr_counter_t instrs_count = scopes_tree_count_instructions (scope_p);
  const size_t blocks_count = JERRY_ALIGNUP (instrs_count, BLOCK_SIZE) / BLOCK_SIZE;

  const size_t bytecode_size = JERRY_ALIGNUP (instrs_count * sizeof (vm_instr_t), MEM_ALIGNMENT);
  const size_t hash_table_size = lit_id_hash_table_get_size_for_table (buckets_count, blocks_count);
  const size_t header_and_hash_table_size = JERRY_ALIGNUP (sizeof (bytecode_data_header_t) + hash_table_size,
                                                           MEM_ALIGNMENT);

  uint8_t *buffer_p = (uint8_t*) mem_heap_alloc_block (bytecode_size + header_and_hash_table_size,
                                                       MEM_HEAP_ALLOC_LONG_TERM);

  lit_id_hash_table *lit_id_hash = lit_id_hash_table_init (buffer_p + sizeof (bytecode_data_header_t),
                                                           hash_table_size,
                                                           buckets_count, blocks_count);

  vm_instr_t *bytecode_p = scopes_tree_raw_data (scope_p,
                                                 buffer_p + header_and_hash_table_size,
                                                 bytecode_size,
                                                 lit_id_hash);

  bytecode_data_header_t *header_p = (bytecode_data_header_t *) buffer_p;

  jsp_bc_add_bytecode_data (header_p, lit_id_hash, bytecode_p, instrs_count);

  if (is_show_instrs)
  {
    lit_dump_literals ();
    bc_print_instrs (header_p);
  }

  return header_p;
} /* bc_merge_scopes_into_bytecode */

void
jsp_bc_finalize ()
{
  while (first_bytecode_header_p != NULL)
  {
    bytecode_data_header_t *header_p = first_bytecode_header_p;
    first_bytecode_header_p = MEM_CP_GET_POINTER (bytecode_data_header_t, header_p->next_header_cp);

    mem_heap_free_block (header_p);
  }
} /* jsp_bc_finalize */

